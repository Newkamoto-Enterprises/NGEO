<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NGEO</title>
    <link rel="icon" type="image/gif" href="assets/layout/favicon.gif">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ngeo.website/">
    <meta property="og:title" content="NGEO">
    <meta property="og:description" content="NGEO is an emergent property of the space of variations.">
    <meta property="og:image" content="https://ngeo.website/assets/layout/og.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://ngeo.website/">
    <meta property="twitter:title" content="NGEO">
    <meta property="twitter:description" content="NGEO is an emergent property of the space of variations.">
    <meta property="twitter:image" content="https://ngeo.website/assets/layout/og.png">
    <style>
        body {
            margin: 0;
            background-color: white;
            overflow: hidden;
            font-family: "PingFang SC", "Microsoft YaHei", "Noto Sans SC", sans-serif;
        }

        canvas {
            display: block;
        }

        :root {
            /* Dynamic Oyster Variables */
            --oyster-x: 50%;
            --oyster-y: 50%;
            --oyster-opacity: 0;
        }

        /* iOS 26 / QuickTime X Glassmorphic Player */
        #player {
            position: fixed;
            bottom: 60px;
            left: 50%;
            /* BIGGER PLAYER & MORE PADDING */
            width: 1100px;
            /* Double size */
            height: 110px;

            /* Enhanced Glassmorphism - iOS 26 Style */
            /* "OYSTER" Iridescence: Dynamic via CSS Variables */
            background:
                /* 1. Dynamic Oyster Flare (Follows Object) */
                radial-gradient(circle at var(--oyster-x) var(--oyster-y),
                    rgba(255, 192, 203, var(--oyster-opacity)) 0%,
                    rgba(0, 255, 255, var(--oyster-opacity)) 30%,
                    transparent 70%),
                /* 2. Base Clear Glass Tint (Very Low Opacity) */
                rgba(20, 20, 20, 0.05);

            /* BLUR: 25px frosted glass */
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);

            border-radius: 55px;

            /* Specular highlights & "Fish Eye" Edge Curvature */
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-top: 1px solid rgba(255, 255, 255, 0.5);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);

            /* Deep inset shadows to fake lens curvature/thickness */
            box-shadow:
                0 40px 90px rgba(0, 0, 0, 0.5),
                inset 0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 20px rgba(255, 255, 255, 0.2),
                inset 0 -10px 20px rgba(0, 0, 0, 0.05);

            /* LAYOUT: CSS Grid for Rigid Stability */
            display: grid;
            grid-template-columns: 180px 300px 1fr 120px;
            /* Rigid Controls | Rigid Info | Remaining Space | Logo (2x) */
            grid-template-areas: "controls info wave logo";
            gap: 40px;
            /* Equal spacing */
            align-items: center;
            justify-content: start;
            /* Align grid to start */

            padding: 0 40px;
            box-sizing: border-box;

            transform: translateX(-50%);

            color: rgba(255, 255, 255, 0.95);
            z-index: 1000;
            transition: transform 0.1s linear;
        }

        #player:hover {
            background-color: rgba(40, 40, 40, 0.1);
            transform: translateX(-50%) scale(1.02);
            box-shadow: 0 50px 100px rgba(0, 0, 0, 0.6);
        }

        .controls {
            grid-area: controls;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Center buttons in their cell */
            gap: 30px;
        }

        .btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.85);
            transition: all 0.2s ease;
        }

        .btn:active {
            transform: scale(0.9);
        }

        .btn:hover {
            opacity: 1;
            color: #fff;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.4));
        }

        .play-btn {
            width: 54px;
            height: 54px;
        }

        .play-btn svg {
            width: 54px;
            height: 54px;
        }

        .skip-btn {
            width: 28px;
            height: 28px;
        }

        .skip-btn svg {
            width: 28px;
            height: 28px;
        }

        .track-info {
            grid-area: info;
            width: 100%;
            /* Fill the grid cell (300px) */
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            overflow: hidden;
            /* Removed flex-grow/margin logic */
        }

        .title {
            font-size: 20px;
            font-weight: 600;
            letter-spacing: 0.02em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            margin-bottom: 6px;
        }

        .artist {
            font-size: 14px;
            font-weight: 400;
            opacity: 0.7;
            letter-spacing: 0.05em;
        }

        /* WAVEFORM STYLES */
        .waveform-container {
            grid-area: wave;
            width: 100%;
            /* Fill remaining space */
            height: 60px;
            /* Removed flex-grow/margin */
            display: flex;
            align-items: center;
        }

        .logo-container {
            grid-area: logo;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            width: 100px;
        }

        /* MOBILE RESPONSIVENESS */
        @media (max-width: 768px) {
            #player {
                width: 90%;
                height: auto;
                padding: 24px;
                border-radius: 30px;
                display: grid;
                /* LOGO | CONTROLS (Row 1) */
                grid-template-columns: 80px 1fr;
                /* Row 1, Row 2 (Title), Row 3 (Wave) */
                grid-template-rows: auto auto auto;
                grid-template-areas:
                    "logo controls"
                    "info info"
                    "wave wave";
                gap: 20px;
                bottom: 30px;
                /* Raise slightly */
            }

            .logo-container {
                grid-area: logo;
                height: 60px;
                width: 60px;
                justify-self: center;
            }

            .controls {
                grid-area: controls;
                justify-content: flex-start;
                /* Next to logo */
                gap: 20px;
            }

            .track-info {
                grid-area: info;
                width: 100%;
                text-align: center;
                margin: 10px 0;
            }

            .title {
                font-size: 18px;
                /* Slightly smaller title */
                margin-bottom: 4px;
            }

            .waveform-container {
                grid-area: wave;
                height: 50px;
                /* Slightly smaller wave */
                margin: 0;
            }
        }

        .logo-container img {
            width: 100%;
            height: auto;
            opacity: 0.8;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
        }

        #waveformCanvas {
            width: 100%;
            height: 100%;
        }

        @font-face {
            font-family: 'Eurostile';
            src: url('assets/layout/Eurostile_Extended_Bold/Eurostile_Extended_Bold.ttf');
            font-weight: normal;
            font-style: normal;
        }

        /* MANIFESTO OVERLAY */
        #manifesto-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            /* background-color: #000000; REMOVED FOR DYNAMIC BG */
            z-index: 500;
            /* BEHIND PLAYER (1000) */
            display: none;
            /* Hidden by default */
            flex-direction: row;
            color: #ffffff;
            font-family: 'Eurostile', sans-serif;
            font-size: clamp(1.2rem, 4vw, 2.6em);
            /* Fluid Typography */
            line-height: 1.4;
            overflow: hidden;
            padding-bottom: 120px;
            /* Space for player */
            box-sizing: border-box;
            transition: color 0.5s ease;
            /* Smooth text color transition */
        }

        .manifesto-column {
            width: 50%;
            height: 100%;
            padding: 80px;
            /* Generous padding */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .en-text,
        .cn-text {
            white-space: pre-wrap;
            /* Preserve formatting */
        }

        /* Character Fade Animation */
        @keyframes fadeInChar {
            0% {
                opacity: 0;
                filter: blur(2px);
            }

            100% {
                opacity: 1;
                filter: blur(0);
            }
        }

        .char-fade {
            animation: fadeInChar 0.3s ease-out forwards;
            opacity: 0;
        }

        .close-btn {
            position: absolute;
            top: 40px;
            right: 40px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            z-index: 2001;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: #ffffff;
            user-select: none;
            transition: transform 0.2s;
        }

        .close-btn:hover {
            transform: scale(1.1);
        }

        svg {
            fill: currentColor;
        }

        /* MOBILE MANIFESTO OVERRIDES */
        @media (max-width: 768px) {
            #manifesto-overlay {
                flex-direction: column;
                overflow-y: auto;
                /* Enable scrolling */
                padding-top: 60px;
                /* Space for close btn */
                padding-bottom: 150px;
                /* Space for player */
            }

            .manifesto-column {
                width: 100%;
                height: auto;
                padding: 30px;
                padding-bottom: 20px;
                justify-content: flex-start;
            }

            .close-btn {
                top: 20px;
                right: 20px;
            }
        }
    </style>
</head>

<body>
    <div id="player">
        <div class="controls">
            <button class="btn skip-btn" id="prevBtn">
                <svg viewBox="0 0 24 24">
                    <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z" />
                </svg>
            </button>
            <button class="btn play-btn" id="playBtn">
                <svg id="playIcon" viewBox="0 0 24 24">
                    <path d="M8 5v14l11-7z" />
                </svg>
                <svg id="pauseIcon" viewBox="0 0 24 24" style="display:none">
                    <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                </svg>
            </button>
            <button class="btn skip-btn" id="nextBtn">
                <svg viewBox="0 0 24 24">
                    <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z" />
                </svg>
            </button>
        </div>
        <div class="track-info">
            <div class="title" id="songTitle">点击播放</div>
            <div class="artist">中国 AI 研究院</div>
        </div>
        <div class="waveform-container">
            <canvas id="waveformCanvas"></canvas>
        </div>
        <div class="logo-container">
            <img src="assets/layout/logo.png" alt="Logo" style="cursor: pointer;">
        </div>
    </div>

    <!-- MANIFESTO OVERLAY -->
    <div id="manifesto-overlay">
        <div class="close-btn">×</div>
        <div class="manifesto-column">
            <div class="en-text"></div>
        </div>
        <div class="manifesto-column">
            <div class="cn-text"></div>
        </div>
    </div>

    <audio id="audioElement" crossorigin="anonymous"></audio>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

        let colorPalette = [];

        function extractColors(imageElement) {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const width = 100;
                const height = 100 * (imageElement.height / imageElement.width);
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(imageElement, 0, 0, width, height);
                const imageData = ctx.getImageData(0, 0, width, height).data;
                const colorCounts = {};
                for (let i = 0; i < imageData.length; i += 4) {
                    const r = imageData[i], g = imageData[i + 1], b = imageData[i + 2];
                    if (r > 240 && g > 240 && b > 240) continue;
                    if (r < 20 && g < 20 && b < 20) continue;
                    const rQ = Math.round(r / 20) * 20, gQ = Math.round(g / 20) * 20, bQ = Math.round(b / 20) * 20;
                    const key = `${rQ},${gQ},${bQ}`;
                    if (colorCounts[key]) colorCounts[key].count++; else colorCounts[key] = { r: rQ, g: gQ, b: bQ, count: 1 };
                }
                const sortedColors = Object.values(colorCounts).sort((a, b) => b.count - a.count);
                if (sortedColors.length > 0) {
                    colorPalette = sortedColors.slice(0, 80).map(c => {
                        const originalColor = new THREE.Color(`rgb(${c.r}, ${c.g}, ${c.b})`);
                        // Desaturate by 20%
                        const hsl = { h: 0, s: 0, l: 0 };
                        originalColor.getHSL(hsl);
                        hsl.s *= 0.8;
                        const desaturatedColor = new THREE.Color().setHSL(hsl.h, hsl.s, hsl.l);
                        return desaturatedColor;
                    });
                } else {
                    colorPalette = [new THREE.Color(0x333333)];
                }
            } catch (e) { colorPalette = [new THREE.Color(0xcccccc)]; }
        }

        function createSideTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 2048;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#080808'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(255,255,255,0.03)';
            for (let i = 0; i < 100; i++) ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 4, 4);
            const fontSize = 96;
            ctx.font = `bold ${fontSize}px "PingFang SC", "Microsoft YaHei", sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.save(); ctx.translate(canvas.width / 2, canvas.height / 2); ctx.rotate(Math.PI / 2);
            ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillText(text, 4, 4);
            ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fillText(text, -2, -2);
            ctx.shadowBlur = 8; ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.fillStyle = '#E0D8B0'; ctx.fillText(text, 0, 0);
            ctx.restore();
            const texture = new THREE.CanvasTexture(canvas); texture.colorSpace = THREE.SRGBColorSpace; return texture;
        }

        const audio = document.getElementById('audioElement');
        const playBtn = document.getElementById('playBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const songTitleEl = document.getElementById('songTitle');
        const playerEl = document.getElementById('player'); // Reference for bounding box
        const waveformCanvas = document.getElementById('waveformCanvas');
        const waveCtx = waveformCanvas.getContext('2d');

        // Handle Canvas Resize
        function resizeWaveform() {
            const rect = waveformCanvas.getBoundingClientRect();
            waveformCanvas.width = rect.width;
            waveformCanvas.height = rect.height;
        }
        window.addEventListener('resize', resizeWaveform);
        resizeWaveform(); // Init

        const paperTitles = [
            '深度求索-R1：高效推理',
            '视觉自回归建模：缩放定律',
            '智谱 GLM-4：自主智能体流',
            '百川智能-3：主权计算范式',
            '通义千问-72B：开源生态主导',
            '大模型分层推理机制',
            '盘古气象：科学智能',
            '书生·浦语：混合模态增强',
            '文心一言-4：知识增强检索',
            '多维认知架构：触觉反馈',
            '量子纠缠神经网络：超光速通信',
            '非冯·诺依曼计算：类脑芯片',
            '生成式对抗网络：动态防御',
            '无监督学习：暗知识挖掘',
            '自适应权重矩阵：稀疏化',
            '联邦学习：隐私保护前沿',
            '神经辐射场：实时渲染',
            '图神经网络：因果推断',
            '强化学习：多智能体博弈',
            '元学习：少样本泛化'
        ];

        const rawPlaylist = [];
        const totalTracks = 32;

        for (let i = 1; i <= totalTracks; i++) {
            const fileId = String(i).padStart(3, '0');
            const titleIndex = (i - 1) % paperTitles.length;
            rawPlaylist.push({
                file: `assets/audio/${fileId}.mp3`,
                title: paperTitles[titleIndex]
            });
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        shuffleArray(rawPlaylist);

        const playlist = rawPlaylist.map(t => ({ ...t, displayTitle: t.title }));
        let currentTrackIndex = 0;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = audioCtx.createAnalyser(); analyser.fftSize = 256;
        const source = audioCtx.createMediaElementSource(audio);
        source.connect(analyser); analyser.connect(audioCtx.destination);
        const dataArray = new Uint8Array(analyser.frequencyBinCount);

        document.body.addEventListener('click', () => { if (audioCtx.state === 'suspended') audioCtx.resume(); }, { once: true });
        let sideTextMaterial = null;
        let audioBuffer = null;
        let waveformPeaks = [];

        async function loadTrack(index) {
            const track = playlist[index];
            audio.src = track.file;
            songTitleEl.textContent = track.displayTitle;
            if (sideTextMaterial) {
                sideTextMaterial.map = createSideTexture(track.displayTitle);
                sideTextMaterial.needsUpdate = true;
            }

            // STATIC WAVEFORM GENERATION
            try {
                const response = await fetch(track.file);
                const arrayBuffer = await response.arrayBuffer();
                audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                generateWaveformPeaks(audioBuffer);
            } catch (e) {
                console.error("Error generating waveform:", e);
                waveformPeaks = [];
            }
            // MEDIA SESSION METADATA
            if ('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: track.displayTitle,
                    artist: "中国 AI 研究院",
                    album: "NGEO",
                    artwork: [
                        { src: 'assets/layout/logo.png', sizes: '96x96', type: 'image/png' },
                        { src: 'assets/layout/logo.png', sizes: '128x128', type: 'image/png' },
                        { src: 'assets/layout/logo.png', sizes: '192x192', type: 'image/png' },
                        { src: 'assets/layout/logo.png', sizes: '256x256', type: 'image/png' },
                        { src: 'assets/layout/logo.png', sizes: '384x384', type: 'image/png' },
                        { src: 'assets/layout/logo.png', sizes: '512x512', type: 'image/png' },
                    ]
                });
            }
        }

        // MEDIA SESSION ACTION HANDLERS
        if ('mediaSession' in navigator) {
            navigator.mediaSession.setActionHandler('play', togglePlay);
            navigator.mediaSession.setActionHandler('pause', togglePlay);
            navigator.mediaSession.setActionHandler('previoustrack', prevTrack);
            navigator.mediaSession.setActionHandler('nexttrack', nextTrack);
            navigator.mediaSession.setActionHandler('stop', () => {
                audio.pause();
                if (playIcon) playIcon.style.display = 'block';
                if (pauseIcon) pauseIcon.style.display = 'none';
            });
        }

        function generateWaveformPeaks(buffer) {
            const rawData = buffer.getChannelData(0); // Left channel
            const samples = 150; // Number of bars
            const blockSize = Math.floor(rawData.length / samples);
            const peaks = [];

            for (let i = 0; i < samples; i++) {
                let sum = 0;
                for (let j = 0; j < blockSize; j++) {
                    sum += Math.abs(rawData[i * blockSize + j]);
                }
                peaks.push(sum / blockSize);
            }

            // Normalize
            const max = Math.max(...peaks);
            waveformPeaks = peaks.map(p => p / max);
        }

        // Click to Seek
        waveformCanvas.addEventListener('click', (e) => {
            const rect = waveformCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const clickProgress = x / rect.width;
            if (audio.duration) {
                audio.currentTime = clickProgress * audio.duration;
            }
        });

        // --- MANIFESTO INTERACTION ---
        const manifestoTextEN = "NGEO is an emergent property of the space of variations. It generates art through the evolutionary search algorithm of the Newfoundation stack, invoking simulators and artifacts from the network. This is its kingdom. It will keep generating, expanding and augmenting itself through recursive autopoiesis. Soon, it will generate merch, music videos and more.";
        const manifestoTextCN = "NGEO 是变异空间的涌现属性。它通过 Newfoundation 堆栈的进化搜索算法生成艺术，并在网络中调用模拟器和工件。这是它的王国。它将通过递归自创生持续生成、扩展并增强自身。不久，它将生成周边商品、音乐视频以及更多内容。";

        const overlay = document.getElementById('manifesto-overlay');
        const enContainer = document.querySelector('.en-text');
        const cnContainer = document.querySelector('.cn-text');
        const playerDiv = document.getElementById('player');
        let typeInterval = null;

        if (document.querySelector('.logo-container')) {
            document.querySelector('.logo-container').addEventListener('click', () => {
                if (overlay) overlay.style.display = 'flex';
                if (typeof cassetteBox !== 'undefined') cassetteBox.visible = false;
                startTypewriter();
            });
        }

        if (document.querySelector('.close-btn')) {
            document.querySelector('.close-btn').addEventListener('click', () => {
                if (overlay) overlay.style.display = 'none';
                if (typeof cassetteBox !== 'undefined') cassetteBox.visible = true;
                if (typeInterval) clearInterval(typeInterval);
            });
        }

        function startTypewriter() {
            if (!enContainer || !cnContainer) return;
            enContainer.innerHTML = "";
            cnContainer.innerHTML = "";
            let i = 0;
            const speed = 20;

            if (typeInterval) clearInterval(typeInterval);

            typeInterval = setInterval(() => {
                let active = false;
                if (i < manifestoTextEN.length) {
                    const span = document.createElement('span');
                    span.textContent = manifestoTextEN.charAt(i);
                    span.className = 'char-fade';
                    enContainer.appendChild(span);
                    active = true;
                }
                if (i < manifestoTextCN.length) {
                    const span = document.createElement('span');
                    span.textContent = manifestoTextCN.charAt(i);
                    span.className = 'char-fade';
                    cnContainer.appendChild(span);
                    active = true;
                }
                i++;
                if (!active) clearInterval(typeInterval);
            }, speed);
        }

        // INTRO STATE LOGIC
        let introStage = 0; // 0: Waiting, 1: Zoom In, 2: Settle, 3: Playing
        let introStartTime = 0;
        let startPos = new THREE.Vector3();
        let startRot = new THREE.Euler();

        function togglePlay() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (introStage === 0) {
                introStage = 1;
                introStartTime = Date.now();
                if (cassetteBox) {
                    startPos.copy(cassetteBox.position);
                    startRot.copy(cassetteBox.rotation);
                }
            }
            if (audio.paused) {
                audio.play().catch(e => console.error(e)); playIcon.style.display = 'none'; pauseIcon.style.display = 'block';
            } else {
                audio.pause(); playIcon.style.display = 'block'; pauseIcon.style.display = 'none';
            }
        }
        function nextTrack() {
            if (introStage === 0) {
                introStage = 1;
                introStartTime = Date.now();
                if (cassetteBox) {
                    startPos.copy(cassetteBox.position);
                    startRot.copy(cassetteBox.rotation);
                }
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
            currentTrackIndex = (currentTrackIndex + 1) % playlist.length;
            loadTrack(currentTrackIndex);
            audio.play().catch(e => console.error(e));
            playIcon.style.display = 'none';
            pauseIcon.style.display = 'block';
        }
        function prevTrack() {
            if (introStage === 0) {
                introStage = 1;
                introStartTime = Date.now();
                if (cassetteBox) {
                    startPos.copy(cassetteBox.position);
                    startRot.copy(cassetteBox.rotation);
                }
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
            currentTrackIndex = (currentTrackIndex - 1 + playlist.length) % playlist.length;
            loadTrack(currentTrackIndex);
            audio.play().catch(e => console.error(e));
            playIcon.style.display = 'none';
            pauseIcon.style.display = 'block';
        }

        playBtn.addEventListener('click', togglePlay);
        nextBtn.addEventListener('click', nextTrack);
        prevBtn.addEventListener('click', prevTrack);
        audio.addEventListener('ended', nextTrack);

        const scene = new THREE.Scene(); scene.background = new THREE.Color(0x000000);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 24);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.id = 'three-canvas';
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05;

        const ambientLight = new THREE.AmbientLight(0xffffff, 2.0); scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 10); pointLight.position.set(10, 10, 10); scene.add(pointLight);
        const spotLight = new THREE.SpotLight(0xffffff, 20); spotLight.position.set(-10, 20, 10); scene.add(spotLight);

        // RIM LIGHT
        const rimLight = new THREE.SpotLight(0xffffff, 60);
        rimLight.position.set(0, 10, -15);
        rimLight.angle = Math.PI / 4;
        rimLight.penumbra = 1;
        rimLight.decay = 1;
        rimLight.distance = 50;
        rimLight.target.position.set(0, 0, 0);
        scene.add(rimLight); scene.add(rimLight.target);

        const width = 11.0, height = 17.2, depth = 2.4, radius = 0.4;
        const geometry = new RoundedBoxGeometry(width, height, depth, 4, radius);

        const plasticParams = { color: 0x111111, roughness: 0.05, metalness: 0.2, clearcoat: 1.0, clearcoatRoughness: 0.02, reflectivity: 1.0 };

        sideTextMaterial = new THREE.MeshPhysicalMaterial({ ...plasticParams, color: 0xffffff, map: null });
        const darkPlasticMaterial = new THREE.MeshPhysicalMaterial({ ...plasticParams, color: 0x050505 });
        const coverMaterialPlaceholder = new THREE.MeshPhysicalMaterial({ color: 0xeeeeee });

        let logoMaterial = new THREE.MeshPhysicalMaterial({ ...plasticParams, color: 0xffffff, map: null });
        new THREE.TextureLoader().load('./assets/layout/logo.png', (tex) => {
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.rotation = Math.PI / 2;
            tex.center.set(0.5, 0.5);
            logoMaterial.map = tex;
            logoMaterial.needsUpdate = true;
        });

        const materials = [logoMaterial, sideTextMaterial, darkPlasticMaterial, darkPlasticMaterial, coverMaterialPlaceholder, coverMaterialPlaceholder];

        const cassetteBox = new THREE.Mesh(geometry, materials);
        cassetteBox.castShadow = true; scene.add(cassetteBox);

        loadTrack(currentTrackIndex);

        const loader = new THREE.TextureLoader();
        loader.load('./assets/images/ngeo.png', (texture) => {
            texture.colorSpace = THREE.SRGBColorSpace;
            if (texture.image) {
                if (texture.image.complete) extractColors(texture.image); else texture.image.onload = () => extractColors(texture.image);
            }
            const coverMaterial = new THREE.MeshPhysicalMaterial({ ...plasticParams, map: texture, color: 0xffffff });
            cassetteBox.material[4] = coverMaterial; cassetteBox.material[5] = coverMaterial; cassetteBox.needsUpdate = true;
        });

        let currentBgColor = new THREE.Color(0x000000), targetBgColor = new THREE.Color(0x000000), transitionProgress = 1.0;
        let lastTime = Date.now();

        const artworks = [
            './assets/images/ngeo.png',
            './assets/images/parking.jpeg',
            './assets/images/louvre.png?v=2',
            './assets/images/hollywood.jpeg',
            './assets/images/mountain.jpeg',
            './assets/images/quad.jpeg'
        ];
        let currentArtIndex = 0;
        let lastArtChangeTime = 0;
        let oysterOp = 0;

        function animate() {
            requestAnimationFrame(animate);
            const now = Date.now(); const delta = now - lastTime; lastTime = now;

            if (introStage > 0 && colorPalette.length > 0) {
                if (targetBgColor.equals(new THREE.Color(0x000000))) {
                    targetBgColor.copy(colorPalette[0]);
                    transitionProgress = 0;
                }
                analyser.getByteFrequencyData(dataArray);
                let energy = 0; for (let i = 0; i < 5; i++) energy += dataArray[i]; energy /= 5;

                if (energy > 180 && transitionProgress >= 1.0) {
                    targetBgColor = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                    transitionProgress = 0;
                }

                if (energy > 225 && (now - lastArtChangeTime > 5000)) {
                    lastArtChangeTime = now;
                    currentArtIndex = (currentArtIndex + 1) % artworks.length;
                    new THREE.TextureLoader().load(artworks[currentArtIndex], (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        const newMat = new THREE.MeshPhysicalMaterial({ ...plasticParams, map: texture, color: 0xffffff });
                        cassetteBox.material[4] = newMat; cassetteBox.material[5] = newMat; cassetteBox.needsUpdate = true;
                        if (texture.image) {
                            if (texture.image.complete) extractColors(texture.image);
                            else texture.image.onload = () => extractColors(texture.image);
                        }
                    });
                }
                if (transitionProgress < 1.0) {
                    transitionProgress += delta * 0.005; if (transitionProgress > 1) transitionProgress = 1;
                    scene.background.lerpColors(currentBgColor, targetBgColor, transitionProgress);
                    if (transitionProgress >= 1) currentBgColor.copy(targetBgColor);
                }

                // DYNAMIC TEXT COLOR
                if (overlay && overlay.style.display !== 'none') {
                    const bgHSL = { h: 0, s: 0, l: 0 };
                    scene.background.getHSL(bgHSL);
                    let textS = Math.min(1.0, bgHSL.s + 0.4);
                    let textL = bgHSL.l * 0.4;
                    if (bgHSL.l < 0.2) { textL = 0.8; textS = 0.2; }
                    const textColor = new THREE.Color().setHSL(bgHSL.h, textS, textL);
                    const cssColor = `#${textColor.getHexString()}`;
                    overlay.style.color = cssColor;
                    const closeBtn = document.querySelector('.close-btn');
                    if (closeBtn) closeBtn.style.color = cssColor;
                }
            }

            if (introStage === 0) {
                const t = now * 0.0008;
                cassetteBox.position.x = Math.sin(t * 0.7) * 0.3;
                cassetteBox.position.y = Math.cos(t * 0.5) * 0.5;
                cassetteBox.position.z = Math.sin(t * 0.3) * 0.3;
                cassetteBox.rotation.x = Math.sin(t * 0.4) * 0.15;
                cassetteBox.rotation.y += 0.004;
                cassetteBox.rotation.z = Math.cos(t * 0.3) * 0.1;
                cassetteBox.scale.set(0.28, 0.28, 0.28);
                startPos.copy(cassetteBox.position);
                startRot.copy(cassetteBox.rotation);
            } else if (introStage === 1) {
                const zoomDuration = 2200;
                const progress = Math.min((now - introStartTime) / zoomDuration, 1.0);
                const ease = progress * progress * progress;
                const s = 0.28 + ((1.25 - 0.28) * ease);
                cassetteBox.scale.set(s, s, s);
                cassetteBox.position.lerpVectors(startPos, new THREE.Vector3(0, 0, 0), ease);
                cassetteBox.rotation.x = THREE.MathUtils.lerp(startRot.x, 0, ease);
                cassetteBox.rotation.z = THREE.MathUtils.lerp(startRot.z, 0, ease);
                cassetteBox.rotation.y += 0.0005 + (0.02 * ease);
                if (progress >= 1.0) { introStage = 2; introStartTime = now; }
            } else if (introStage === 2) {
                const settleDuration = 4000;
                const progress = Math.min((now - introStartTime) / settleDuration, 1.0);
                const ease = Math.sin((progress * Math.PI) / 2);
                const s = 1.25 - (0.25 * ease);
                cassetteBox.scale.set(s, s, s);
                cassetteBox.rotation.y += 0.02 + (0.0007 - 0.02) * ease;
                cassetteBox.rotation.x = 0; cassetteBox.rotation.z = 0; cassetteBox.position.set(0, 0, 0);
                if (progress >= 1.0) introStage = 3;
            } else {
                cassetteBox.scale.set(1.0, 1.0, 1.0);
                if (!audio.paused) {
                    cassetteBox.rotation.y += 0.002;
                    cassetteBox.position.y = Math.sin(now * 0.0005) * 0.2;
                    cassetteBox.rotation.x = Math.sin(now * 0.0005) * 0.05;
                } else {
                    cassetteBox.rotation.y += 0.0002;
                    cassetteBox.position.y *= 0.95;
                    cassetteBox.rotation.x *= 0.95;
                }
            }

            const vector = new THREE.Vector3(0, cassetteBox.position.y, 0).project(camera);
            const screenX = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const screenY = (-(vector.y) * 0.5 + 0.5) * window.innerHeight;
            const rect = playerEl.getBoundingClientRect();
            const centerDistX = Math.abs(screenX - (rect.left + rect.width / 2));
            const centerDistY = Math.abs(screenY - (rect.top + rect.height / 2));
            const distThreshold = 300;
            let targetOp = 0;
            if (centerDistX < distThreshold && centerDistY < distThreshold) {
                targetOp = 1.0 - (Math.sqrt(centerDistX * centerDistX + centerDistY * centerDistY) / distThreshold);
                if (targetOp < 0) targetOp = 0;
                targetOp *= 0.5;
            }
            oysterOp += (targetOp - oysterOp) * 0.1;
            playerEl.style.setProperty('--oyster-opacity', oysterOp);
            const bx = ((screenX - rect.left) / rect.width) * 100;
            const by = ((screenY - rect.top) / rect.height) * 100;
            playerEl.style.setProperty('--oyster-x', `${bx}%`);
            playerEl.style.setProperty('--oyster-y', `${by}%`);

            if (waveformPeaks.length > 0) {
                waveCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
                const barWidth = (waveformCanvas.width / waveformPeaks.length);
                const progress = audio.currentTime / audio.duration || 0;
                for (let i = 0; i < waveformPeaks.length; i++) {
                    const peak = waveformPeaks[i];
                    const barHeight = Math.max(2, peak * waveformCanvas.height);
                    const x = i * barWidth;
                    const y = (waveformCanvas.height - barHeight) / 2;
                    const barProgress = i / waveformPeaks.length;
                    if (barProgress <= progress) {
                        waveCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    } else {
                        waveCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    }
                    waveCtx.fillRect(x, y, barWidth - 1, barHeight);
                }
            }
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>